# -*- coding: utf-8 -*-
"""
/***************************************************************************
 center_selectDockWidget
                                 A QGIS plugin
 Center and select features from a vector layer
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2022-05-04
        git sha              : $Format:%H$
        copyright            : (C) 2022 by SbasGM
        email                : sbasglzmir@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os

from qgis.PyQt import QtGui, QtWidgets, uic
from qgis.PyQt.QtCore import pyqtSignal
from qgis.PyQt.QtWidgets import QTableWidgetItem

from qgis.utils import iface
from qgis.core import (
    QgsProject, 
    QgsVectorLayer,  
    Qgis, 
    QgsFeatureRequest
)

FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'center_select_dockwidget_base.ui'))


class center_selectDockWidget(QtWidgets.QDockWidget, FORM_CLASS):

    closingPlugin = pyqtSignal()

    def __init__(self, parent=None):
        """Constructor."""
        super(center_selectDockWidget, self).__init__(parent)
        # Set up the user interface from Designer.
        # After setupUI you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://doc.qt.io/qt-5/designer-using-a-ui-file.html
        # #widgets-and-dialogs-with-auto-connect
        self.setupUi(self)


        # Connect gui to our funtions ******************************************************
        # Layer fields comboBox connection
        self.layer_cbox.currentIndexChanged.connect(self.get_sel_layer_fields)
        self.layer_cbox.currentIndexChanged.connect(self.enabled_cboxes)

        # Unique values of extract by location algorithm result layer
        self.sel_fields_cbox.currentIndexChanged.connect(self.get_sel_unique_field_values)
        self.next_btn.clicked.connect(self.next_unique_field_value)
        self.previous_btn.clicked.connect(self.previous_unique_field_value)

        # Center selected feature button connection
        self.center_feat_btn.clicked.connect(self.center_feature_value)

        # Add to selection button
        self.add_sel_btn.clicked.connect(self.add_select_feature_sel_layer)

        # Create new layer with all selected features
        self.add_selfeat_lyr_btn.clicked.connect(self.create_new_layer_sel_feat)

        # Delete selected rows in selected features button
        self.del_sel_row_btn.clicked.connect(self.del_row_selected_feat_table)

        # Clear tables and selection on second frame
        self.clear_tables.clicked.connect(self.reset_selection_tables)

        # Refresh layer in widget
        self.reset_all_btn.clicked.connect(self.reset_widget)

        # Set variables *******************************************************************
        # Get Layers
        self.layers = [layer for layer in QgsProject.instance().mapLayers().values()]
        self.valid_layers = [layer.name() for layer in self.layers if (layer.isValid() & isinstance(layer, QgsVectorLayer))]
        # Add empy value to layer list
        self.empy_value = ''
        self.valid_layers.insert(0, self.empy_value)

        # Extraction and seleccion layer comboBox
        self.layer_cbox.clear() # Clear layer comboBox from previus run
        self.layer_cbox.addItems(self.valid_layers)
        self.layer_cbox.setCurrentText(self.empy_value)

        # Clear table of center feature
        self.center_feature_table.clearContents()
        self.center_feature_table.setRowCount(0)
        self.center_feature_table.setColumnCount(0)

        # Clear table of selected features
        self.features_add_sel_table.clearContents()
        self.features_add_sel_table.setRowCount(0)
        self.features_add_sel_table.setColumnCount(0)

        # Clear comboBox of center feature
        self.sel_fields_cbox.clear() 
        self.sel_value_cbox.clear()
        
        # Dict with all selected features and his feature id from the vector layer
        self.features_on_table = {}

    
    
    def enabled_cboxes(self):
        # Enable the selection extract fields and values until spatial predicate is executed
        self.sel_fields_cbox.setEnabled(True)
        self.sel_value_cbox.setEnabled(True)



    def get_sel_layer_fields(self):
        '''
        This function creates a list with the field names from the sel-extrac layer selected on the dialog
        '''
        # Clear comboBox of previuos values
        self.sel_fields_cbox.clear()
        if self.layer_cbox.currentIndex() >= 1:
            valid_layer = QgsProject.instance().mapLayersByName(self.layer_cbox.currentText())

            if len(valid_layer) > 0:
                # Get fields
                valid_layer = valid_layer[0]
                layer_fields = [field.name() for field in valid_layer.fields()]
                layer_fields.insert(0, self.empy_value)

                # Load layer fields on dialog, and add list to sel-extr layer fields to comboBox
                try:
                    self.sel_fields_cbox.addItems(sorted(layer_fields))
                except:
                    self.sel_fields_cbox.addItems([str(i) for i in layer_fields])

                self.sel_fields_cbox.setCurrentText(self.empy_value)
                self.selected_layer = valid_layer

        # Disable add to selection button
        self.add_sel_btn.setEnabled(False)



    def get_sel_unique_field_values(self):
        '''
        This function creates a list with the unique field values of the sel-extrac layer
        '''
        # Clear comboBox of previus values
        self.sel_value_cbox.clear()
        if self.sel_fields_cbox.currentIndex() >= 1:
            # Get current value in cbox
            current_cbox_value = self.sel_fields_cbox.currentText()
            # Get unique values of selected field
            values = [feature[current_cbox_value] for feature in self.selected_layer.getFeatures()]
            unique_values = list(set(values))
            unique_values.insert(0, self.empy_value)

            # Load fields values on dialog, and add list to sel-extr fields values to comboBox
            try: 
                self.sel_value_cbox.addItems(sorted(unique_values))
            except:
                self.sel_value_cbox.addItems([str(i) for i in unique_values])

            # sSet up the currect cbox text as an empy
            self.sel_value_cbox.setCurrentText(self.empy_value)
            self.lyr_sel_field = current_cbox_value

        # Disable add to selection button
        self.add_sel_btn.setEnabled(False)



    def next_unique_field_value(self):
        count = self.sel_value_cbox.count()
        if count >= 1:
            current_index = self.sel_value_cbox.currentIndex()
            if current_index != count:
                self.sel_value_cbox.setCurrentIndex(current_index + 1)

        # Disable add to selection button
        self.add_sel_btn.setEnabled(False)



    def previous_unique_field_value(self):
        count = self.sel_value_cbox.count()
        if count >= 1:
            current_index = self.sel_value_cbox.currentIndex()
            if current_index != 0:
                self.sel_value_cbox.setCurrentIndex(current_index - 1)

        # Disable add to selection button
        self.add_sel_btn.setEnabled(False)



    def center_feature_value(self):
        if self.sel_value_cbox.currentText() != '':
            # Create separate expression depending on the data type of the field 
            if isinstance(type(self.lyr_sel_field), str):
                expression = "'{}' = '{}'".format(self.sel_value_cbox.currentText(), self.lyr_sel_field)
            else:
                expression = "'{}' = {}".format(self.sel_value_cbox.currentText(), self.lyr_sel_field)
            
            # Select values of extract by location retult layer
            self.selected_layer.selectByExpression(expression, self.selected_layer.SetSelection)
            
            
            # Zoom to selected feature
            box = self.selected_layer.boundingBoxOfSelected()
            iface.mapCanvas().setExtent(box)
            iface.mapCanvas().refresh()
    
            # Create table ****************************************************************************
            # Get selected features
            features = [feature for feature in self.selected_layer.getSelectedFeatures()]
            fields = [field.name() for field in self.selected_layer.fields()]
            # Set colunms and rows
            # Claer table from previous values
            self.center_feature_table.clearContents()
            self.center_feature_table.setRowCount(0)
            self.center_feature_table.setColumnCount(len(fields))

            # Add column names
            self.center_feature_table.setHorizontalHeaderLabels(fields)
            
            # Add data to table
            row_pos = 0
            for feature in features:
                self.center_feature_table.insertRow(row_pos)

                for attr_idx, value in enumerate(feature.attributes()):
                    self.center_feature_table.setItem(row_pos, attr_idx, QTableWidgetItem(str(value)))

                row_pos = row_pos + 1

            # Disable add to selection button
            self.add_sel_btn.setEnabled(True)



    def add_select_feature_sel_layer(self):
        # Get the number of currently selected features in the based layer
        selected_features = [feature for feature in self.selected_layer.getSelectedFeatures()]
        fields = [field.name() for field in self.selected_layer.fields()]
        features = []
        # Comprove that a feature is selected
        if len(selected_features) == 0:

            iface.messageBar().pushMessage(
                'There no selected features to add',
                level = Qgis.Warning,
                duration = 6
            )

        # Comprobar si hay una seleccion activate
        if self.features_add_sel_table.rowCount() == 0:

            # Add data to table
            row_pos = 0
            # Claer table from previous values
            self.features_add_sel_table.clearContents()
            self.features_add_sel_table.setRowCount(0)
            self.features_add_sel_table.setColumnCount(len(fields))
            
            # Add column names
            self.features_add_sel_table.setHorizontalHeaderLabels(fields)
            
            for sel_feature in selected_features:
                
                '''
                For been able to deselect features we have to store the attributes of the table as values in
                a dictionary using the feature object as keys. By doing this, later we can relate more easily the row of the table 
                with his feature counterpart on the vector layer. Also its important to save the attributes values on 
                str format because is only format that the QWidget Table acepts.
                '''
                self.features_on_table[sel_feature] = [str(attribute) for attribute in sel_feature.attributes()]

                # Insert row on table
                self.features_add_sel_table.insertRow(row_pos)
                # Insert value on selected features table
                for attr_idx, value in enumerate(sel_feature.attributes()): 
                    self.features_add_sel_table.setItem(row_pos, attr_idx, QTableWidgetItem(str(value)))
                
                row_pos = row_pos + 1

        elif self.features_add_sel_table.rowCount() >= 1:
            # Add features to deselect dict
            for sel_feature in selected_features:
                
                # Evaluate if we're duplicating data
                # Get all features ids for evaluation
                if sel_feature.id() in [feature.id() for feature in self.features_on_table.keys()]:
                    iface.messageBar().pushMessage(
                        f'The feature: {sel_feature.id()} is already on table',
                        level = Qgis.Warning,
                        duration = 6
                    )
                else:
                    self.features_on_table[sel_feature] = [str(attribute) for attribute in sel_feature.attributes()]
                    # Insert new row on selected features table
                    # Insert a new row
                    row_pos = self.features_add_sel_table.rowCount()
                
                    # Insert values on the new row
                    self.features_add_sel_table.insertRow(row_pos)

                    for attr_idx, value in enumerate(sel_feature.attributes()):
                        self.features_add_sel_table.setItem(row_pos, attr_idx, QTableWidgetItem(str(value)))

                    row_pos = row_pos + 1

        # Disable add to selection button
        self.add_sel_btn.setEnabled(False)



    def del_row_selected_feat_table(self):
        indx = self.features_add_sel_table.selectionModel().selectedRows()

        if len(indx) == 1:

            selected_row = self.features_add_sel_table.currentRow()
            attributes = []
            # Extrac all values in cells
            for column in range(0, self.features_add_sel_table.columnCount()):
                # Acces each column value 
                column_in_row = self.features_add_sel_table.item(selected_row, column)
                attributes.append(column_in_row.text())

            # Search coincidence of atributes on feature on table dict and deselect feature with his id
            # Create a copy of dict for avoiding change during iteration error            
            for key, value in list(self.features_on_table.items()):
                if value == attributes:
                    try:
                        del self.features_on_table[key]
                    except:
                        iface.messageBar().pushMessage(
                            "Error. There's no selected feature with the same attributes display on the table. Please reset tables",
                            level = Qgis.Warning,
                            duration = 6
                        )

            # Reset selection of layer and the find all the features id for a create the new selection 
            features_ids = []
            for feature in self.selected_layer.getFeatures():
                for compare_feature in self.features_on_table.keys():
                    if feature.geometry().equals(compare_feature.geometry()):
                        features_ids.append(feature.id())
            
            self.selected_layer.removeSelection()
            self.selected_layer.select(features_ids)

            self.features_add_sel_table.removeRow(selected_row)

        else:
            iface.messageBar().pushMessage(
                'Please only select one row',
                level = Qgis.Warning,
                duration = 6
            )



    def reset_selection_tables(self):
        # Remove selection
        self.selected_layer.removeSelection()

        # Clear tables
        self.center_feature_table.clearContents()
        self.center_feature_table.setRowCount(0)
        self.center_feature_table.setColumnCount(0)
        
        self.features_add_sel_table.clearContents()
        self.features_add_sel_table.setRowCount(0)
        self.features_add_sel_table.setColumnCount(0)

        # Reset features on table dict
        self.features_on_table = {}
        
        # Disable add to selection button
        self.add_sel_btn.setEnabled(False)

            

    def create_new_layer_sel_feat(self):

        if len([feature for feature in self.selected_layer.getSelectedFeatures()]) != 0:
            # Create nwe layer
            new_layer = self.selected_layer.materialize(QgsFeatureRequest().setFilterFids([feature.id() for feature in self.features_on_table.keys()]))
            new_layer.setName('Manually Selected')
            QgsProject.instance().addMapLayer(new_layer)
        else:
            iface.messageBar().pushMessage(
                "There's no selected features to export as layer",
                level = Qgis.Warning,
                duration = 6
            )



    def reset_widget(self):
        '''
        This function reset all variables and states of the widget

        '''
        self.layers = [layer for layer in QgsProject.instance().mapLayers().values()]
        self.valid_layers = [layer.name() for layer in self.layers if (layer.isValid() & isinstance(layer, QgsVectorLayer))]
        # Add empy value to layer list
        self.empy_value = ''
        self.valid_layers.insert(0, self.empy_value)

        # Extraction and seleccion layer comboBox
        self.layer_cbox.clear() # Clear layer comboBox from previus run
        self.layer_cbox.addItems(self.valid_layers)
        self.layer_cbox.setCurrentText(self.empy_value)

        # Disabled the selection extract fields and values until spatial predicate is executed
        self.sel_fields_cbox.setEnabled(False)
        self.sel_value_cbox.setEnabled(False)

        # Clear table of center feature
        self.center_feature_table.clearContents()
        self.center_feature_table.setRowCount(0)

        # Clear table of selected features
        self.features_add_sel_table.clearContents()
        self.features_add_sel_table.setRowCount(0)

        # Clear comboBox of center feature
        self.sel_fields_cbox.clear() 
        self.sel_value_cbox.clear()

        self.features_on_table = {}



    def closeEvent(self, event):
        self.closingPlugin.emit()
        event.accept()
        self.reset_widget
